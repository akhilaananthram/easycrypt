(** Encrypt-then-MAC and MAC-then-Encrypt -- Generic Reductions **)
require import Option Bool Int FSet Real Distr.
require (*--*) SKE MACs.

(** We now reason about the security of MtE(E,M) for an
    IND-CPA secure SKE E and a SUF-CMA secure MAC M whose
    types align                                           **)
theory MtE.
  type mK, eK, ptxt, ctxt, tag.

  (** Tags are completely public... **)
  type leaks.
  op leak: ptxt -> leaks.

  (** We instantiate the security notions for E and M **)
  clone SKE as SKEa with
    type eK                   <- eK,
    type ptxt                 <- ptxt * tag,
    type ctxt                 <- ctxt,
    type leaks                <- leaks,
    op   leak (pt:ptxt * tag) <- leak pt.`1.

  clone MACs as MACa with
    type mK   <- mK,
    type msg  <- ptxt,
    type tag  <- tag.

  (** ... and for EtM(E,M) **)
  clone import SKE as Sec with
    type eK    <- eK * mK,
    type ptxt  <- ptxt,
    type ctxt  <- ctxt,
    type leaks <- leaks,
    op   leak  <- leak.

  (** The black-box construction is as follows **)
  module MacThenEncrypt(E:SKEa.Enc_Scheme, M:MACa.MAC_Scheme): Enc_Scheme = {
    proc keygen(): eK * mK = {
      var ek, mk;

      ek <@ E.keygen();
      mk <@ M.keygen();
      return (ek,mk);
    }

    proc enc(k:eK * mK, p:ptxt): ctxt = {
      var ek, mk, c, t;

      (ek,mk) <- k;
      t       <@ M.tag(mk,p);
      c       <@ E.enc(ek,(p,t));
      return c;
    }

    proc dec(k:eK * mK, c:ctxt): ptxt option = {
      var ek, mk, t, b, pt, p';
      var p = None;

      (ek,mk) <- k;
      pt      <@ E.dec(ek,c);
      if (pt <> None) {
        (p',t) <- oget pt;
        b      <@ M.verify(mk,p',t);
        p      <- if b then Some p' else None;
      }
      return p;
    }
  }.

  (** A useful result for use later on **)
  section Losslessness.
    declare module E:SKEa.Enc_Scheme.
    declare module M:MACa.MAC_Scheme.

    lemma MtE_keygen_ll:
      islossless E.keygen =>
      islossless M.keygen =>
      islossless MacThenEncrypt(E,M).keygen.
    proof.
      move=> E_ll M_ll.
      by proc; call M_ll; call E_ll.
    qed.

    lemma MtE_enc_ll:
      islossless E.enc =>
      islossless M.tag =>
      islossless MacThenEncrypt(E,M).enc.
    proof.
      move=> E_ll M_ll.
      by proc; call E_ll; call M_ll; auto.
    qed.

    lemma MtE_dec_ll:
      islossless E.dec =>
      islossless M.verify =>
      islossless MacThenEncrypt(E,M).dec.
    proof.
      move=> E_ll M_ll.
      proc; seq  3: true 1%r 1%r 0%r _ => //=.
        by call E_ll; wp.
        by if=> //=; wp; call M_ll; wp.
    qed.
  end section Losslessness.

  (** We first prove that if E is IND-CPA, then MtE(E,M) is IND-CPA **)
  theory CPA_WUF_CPA.
    import CPA.

    (* The MAC and the CPA adversary against MtE(E,M) are combined
       to construct a CPA adversary againt E                           *)
    module CPAa(M:MACa.MAC_Scheme, A:CPA_Adversary, O:SKEa.CPA.CPA_Oracles) = {
      module Sim : CPA_Oracles = {
        proc lr(p0, p1:ptxt): ctxt = {
          var t0, t1;
          var c <- witness;

          if (leak p0 = leak p1) {
            t0 <@ M.tag(MACa.WUF_CMA.WUF_Wrap.k,p0);
            t1 <@ M.tag(MACa.WUF_CMA.WUF_Wrap.k,p1);
            c  <@ O.lr((p0,t0),(p1,t1));
          }
          return c;
        }
      }

      module B = A(Sim)

      proc distinguish(): bool = {
        var b;

        MACa.WUF_CMA.WUF_Wrap.k <@ M.keygen();
        b                       <@ B.distinguish();
        return b;
      }

    }.

    section CPA.
      declare module E:SKEa.Enc_Scheme { CPA_Wrap, SKEa.CPA.CPA_Wrap, MACa.WUF_CMA.WUF_Wrap }.
      declare module M:MACa.MAC_Scheme { CPA_Wrap, SKEa.CPA.CPA_Wrap, MACa.WUF_CMA.WUF_Wrap, E }.
      declare module A:CPA_Adversary   { CPA_Wrap, SKEa.CPA.CPA_Wrap, MACa.WUF_CMA.WUF_Wrap, E, M }.

      axiom M_tag_ll: islossless M.tag.

      (* This requires that the MA scheme is a MAC *)
      axiom tag_op: exists mac,
           (forall gm _k _m,
              hoare [M.tag: (glob M) = gm /\ k = _k /\ m = _m
                        ==> (glob M) = gm /\ res = mac _k _m])
        /\ (forall _k _m _t,
              hoare [M.verify: k = _k /\ m = _m /\ t = _t ==> res <=> (mac _k _m = _t)]).
      choice tag with tag_op.

      local lemma CPA_prob &m:
        Pr[IND_CPA(MacThenEncrypt(E,M),A).main() @ &m: res]
        = Pr[SKEa.CPA.IND_CPA(E,CPAa(M,A)).main() @ &m: res].
      proof.
        byequiv=> //=.
        proc; inline *; swap{2} 3 -1.
        wp; call (_:    ={glob E, glob M}
                     /\ CPA_Wrap.b{1} = SKEa.CPA.CPA_Wrap.b{2}
                     /\ CPA_Wrap.k{1} = (SKEa.CPA.CPA_Wrap.k,MACa.WUF_CMA.WUF_Wrap.k){2}).
          proc; inline *.
          sp; if=>//=; rcondt{2} 6.
            by auto; do ! call (_: true).
          wp=> /=; call (_: true)=> //=.
          wp=> /=.
          case (CPA_Wrap.b{1}).
            (* p1 is used *)
            call (_: true).
            wp=> /=.
            exists* (glob M){2}, MACa.WUF_CMA.WUF_Wrap.k{2}, p0{2}.
            elim* => gm _k _m.
            call{2} (_: (glob M) = gm /\ k = _k /\ m = _m ==> (glob M) = gm).
              have [h _]:= tagE; have tag_spec:= h gm _k _m.
              by conseq* M_tag_ll tag_spec.
            by auto; smt.
            (* p0 is used *)
            seq  5  1: (   t{1} = t0{2}
                        /\ p2{1} = p0{2}
                        /\ ={glob E, glob M}
                        /\ !CPA_Wrap.b{1}
                        /\ CPA_Wrap.b{1} = SKEa.CPA.CPA_Wrap.b{2}
                        /\ CPA_Wrap.k{1} = (SKEa.CPA.CPA_Wrap.k,MACa.WUF_CMA.WUF_Wrap.k){2}
                        /\ ek{1} = SKEa.CPA.CPA_Wrap.k{2}).
              call (_: true).
              by auto; smt.
            exists* (glob M){2}, MACa.WUF_CMA.WUF_Wrap.k{2}, p1{2}.
            elim* => gm _k _m.
            call{2} (_: (glob M) = gm /\ k = _k /\ m = _m ==> (glob M) = gm).
              have [h _]:= tagE; have tag_spec:= h gm _k _m.
              by conseq* M_tag_ll tag_spec.
            by auto; smt.
        rnd.
        wp; call (_: true).
        by wp; call (_: true).
      qed.

      (* Adv^{CPA}_{MacThenEncrypt(E,M)}(A) = Adv^{CPA}_{E}(CPAa(A)) *)
      lemma CPA_preservation &m:
        2%r * Pr[IND_CPA(MacThenEncrypt(E,M),A).main() @ &m: res] - 1%r
        = 2%r * Pr[SKEa.CPA.IND_CPA(E,CPAa(M,A)).main() @ &m: res] - 1%r.
      proof. by rewrite (CPA_prob &m). qed.
    end section CPA.

    (* print CPA_prob *)
    print CPA_preservation.
  end CPA_WUF_CPA.

  (** We then prove that if E is IND-CPA and M is SUF-CMA then MacThenEncrypt(E,M) is INT-PTXT **)
  theory CPA_WUF_PTXT.
    import PTXT.

    (* The SKE and the PTXT adversary against MacThenEncrypt(E,M) are combined
       to construct a CMA adversary againt M                           *)
    module CMAa(E:SKEa.Enc_Scheme, A:PTXT_Adversary, O:MACa.CMA_Oracles) = {
      module Sim : PTXT_Oracles = {
        proc enc(p:ptxt): ctxt = {
          var c, t;

          t <@ O.tag(p);
          c <@ E.enc(SKEa.CPA.CPA_Wrap.k,(p,t));
          return c;
        }

        proc verify(c:ctxt): bool = {
          var t, pt, p;
          var b = false;

          pt <@ E.dec(SKEa.CPA.CPA_Wrap.k,c);
          if (pt <> None) {
            (p,t) <- oget pt;
            b     <@ O.verify(p,t);
          }
          return b;
        }
      }

      proc forge(): unit = {
        SKEa.CPA.CPA_Wrap.k <@ E.keygen();
                               A(Sim).forge();
      }
    }.

    section PTXT.
      declare module E:SKEa.Enc_Scheme { PTXT_Wrap, SKEa.CPA.CPA_Wrap, MACa.WUF_CMA.WUF_Wrap }.
      declare module M:MACa.MAC_Scheme { PTXT_Wrap, SKEa.CPA.CPA_Wrap, MACa.WUF_CMA.WUF_Wrap, E }.
      declare module A:PTXT_Adversary  { PTXT_Wrap, SKEa.CPA.CPA_Wrap, MACa.WUF_CMA.WUF_Wrap, E, M }.

      (* Equivalence up to failure requires termination of oracles and adversaries *)
      axiom E_keygen_ll: islossless E.keygen.
      axiom E_enc_ll   : islossless E.enc.
      axiom E_dec_ll   : islossless E.dec.

      axiom M_keygen_ll: islossless M.keygen.
      axiom M_tag_ll   : islossless M.tag.
      axiom M_verify_ll: islossless M.verify.

      axiom A_forge_ll (O <: PTXT_Oracles { A }):
        islossless O.enc => islossless O.verify => islossless A(O).forge.

      (* Adv^{CTXT}_{MacThenEncrypt(E,M)}(A) <= Adv^{WUF-CMA}_{M}(CMAa(E,A)) *)
      lemma CTXT_security &m:
        Pr[INT_PTXT(MacThenEncrypt(E,M),A).main() @ &m: res]
        <= Pr[MACa.WUF_CMA.WUF_CMA(M,CMAa(E,A)).main() @ &m: res].
      proof.
        byequiv=> //=.
        proc; inline *.
        call (_: MACa.WUF_CMA.WUF_Wrap.win,
                    ={glob E, glob M}
                 /\ PTXT_Wrap.k{1} = (SKEa.CPA.CPA_Wrap.k,MACa.WUF_CMA.WUF_Wrap.k){2}
                 /\ (forall p, mem p PTXT_Wrap.s{1} <=> mem p MACa.WUF_CMA.WUF_Wrap.s{2})
                 /\ (PTXT_Wrap.win{1} => MACa.WUF_CMA.WUF_Wrap.win{2})).
          (* adversary is lossless *)
          exact/A_forge_ll.
          (* encryption oracle *)
          (* equivalence *)
          proc; inline *.
          wp=> /=; call (_: true).
          wp=> /=; call (_: true).
          by auto; smt.
          (* lossless after win *)
          by move=> &2 win; proc; wp; call (MtE_enc_ll E M E_enc_ll M_tag_ll).
          (* lossless and preservation of win *)
          move=> &1; proc; inline *.
          wp; call E_enc_ll.
          wp; call M_tag_ll.
          by auto.
          (* decryption oracle *)
          (* equivalence *)
          proc; inline *.
          seq  5  2: (   !MACa.WUF_CMA.WUF_Wrap.win{2}
                      /\ ={glob E, glob M, c, pt}
                      /\ PTXT_Wrap.k{1} = (SKEa.CPA.CPA_Wrap.k,MACa.WUF_CMA.WUF_Wrap.k){2}
                      /\ (forall p, mem p PTXT_Wrap.s{1} <=> mem p MACa.WUF_CMA.WUF_Wrap.s{2})
                      /\ (PTXT_Wrap.win{1} => MACa.WUF_CMA.WUF_Wrap.win{2})
                      /\ !b{2}
                      /\ k{1} = PTXT_Wrap.k{1}
                      /\ c0{1} = c{1}
                      /\ p0{1} = None
                      /\ (ek,mk){1} = k{1}).
            by call (_: true); auto.
          if=> //=.
            by auto; call (_: true); auto; smt.
          by auto; smt.
        (* lossless after win *)
        by move=> &2 bad; proc; wp; call (MtE_dec_ll E M E_dec_ll M_verify_ll).
        (* lossless and preservation of win *)
        move=> &1; proc; seq  2: true 1%r 1%r 0%r _ (MACa.WUF_CMA.WUF_Wrap.win) => //=.
          by inline *; wp; call (_: true); auto.
          by inline *; wp; call E_dec_ll; auto.
          if=> /=.
            by inline *; auto; call M_verify_ll; auto; smt.
          done.
        (* back to the experiment *)
        swap{2} 4 -3.
        wp; call (_: true).
        wp; call (_: true).
        by auto; smt.
      qed.
    end section PTXT.
  end CPA_WUF_PTXT.
end MtE.

(** We now reason about the security of EtM(E,M) for an
    IND-CPA secure SKE E and a SUF-CMA secure MAC M whose
    types align                                           **)
theory EtM.
  type mK, eK, ptxt, ctxt, tag.

  type leaks.
  op leak: ptxt -> leaks.

  (** We instantiate the security notions for E and M **)
  clone SKE as SKEa with
    type eK    <- eK,
    type ptxt  <- ptxt,
    type ctxt  <- ctxt,
    type leaks <- leaks,
    op   leak  <- leak.

  clone MACs as MACa with
    type mK   <- mK,
    type msg  <- ctxt,
    type tag  <- tag.

  (** ... and for EtM(E,M) **)
  clone import SKE as Sec with
    type eK    <- eK * mK,
    type ptxt  <- ptxt,
    type ctxt  <- ctxt * tag,
    type leaks <- leaks,
    op   leak  <- leak.

  (** The black-box construction is as follows **)
  module EtM(E:SKEa.Enc_Scheme, M:MACa.MAC_Scheme): Enc_Scheme = {
    proc keygen(): eK * mK = {
      var ek, mk;

      ek <@ E.keygen();
      mk <@ M.keygen();
      return (ek,mk);
    }

    proc enc(k:eK * mK, p:ptxt): ctxt * tag = {
      var ek, mk, c, t;

      (ek,mk) <- k;
      c       <@ E.enc(ek,p);
      t       <@ M.tag(mk,c);
      return (c,t);
    }

    proc dec(k:eK * mK, ct:ctxt * tag): ptxt option = {
      var ek, mk, c, t, b;
      var p = None;

      (ek,mk) <- k;
      (c ,t)  <- ct;
      b       <@ M.verify(mk,c,t);
      if (b) { p <@ E.dec(ek,c); }
      return p;
    }
  }.

  (** A useful result for use later on **)
  section Losslessness.
    declare module E:SKEa.Enc_Scheme.
    declare module M:MACa.MAC_Scheme.

    lemma EtM_keygen_ll:
      islossless E.keygen =>
      islossless M.keygen =>
      islossless EtM(E,M).keygen.
    proof.
      move=> E_ll M_ll.
      by proc; call M_ll; call E_ll.
    qed.

    lemma EtM_enc_ll:
      islossless E.enc =>
      islossless M.tag =>
      islossless EtM(E,M).enc.
    proof.
      move=> E_ll M_ll.
      by proc; call M_ll; call E_ll; wp.
    qed.

    lemma EtM_dec_ll:
      islossless E.dec =>
      islossless M.verify =>
      islossless EtM(E,M).dec.
    proof.
      move=> E_ll M_ll.
      proc; seq  4: true 1%r 1%r 0%r _ => //=.
        by call M_ll; wp.
        by if=> //=; call E_ll.
    qed.
  end section Losslessness.

  (** We first prove that if E is IND-CPA, then EtM(E,M) is IND-CPA **)
  theory CPA_SUF_CPA.
    import CPA.

    (* The MAC and the CPA adversary against EtM(E,M) are combined
       to construct a CPA adversary againt E                           *)
    module CPAa(M:MACa.MAC_Scheme, A:CPA_Adversary, O:SKEa.CPA.CPA_Oracles) = {
      module Sim : CPA_Oracles = {
        proc lr(p0, p1:ptxt): ctxt * tag = {
          var t, c;
          var ct <- witness;

          if (leak p0 = leak p1) {
            c  <@ O.lr(p0,p1);
            t  <@ M.tag(MACa.SUF_CMA.SUF_Wrap.k,c);
            ct <- (c,t);
          }
          return ct;
        }
      }

      module B = A(Sim)

      proc distinguish(): bool = {
        var b;

        MACa.SUF_CMA.SUF_Wrap.k <@ M.keygen();
        b                       <@ B.distinguish();
        return b;
      }

    }.

    section CPA.
      declare module E:SKEa.Enc_Scheme { CPA_Wrap, SKEa.CPA.CPA_Wrap, MACa.SUF_CMA.SUF_Wrap }.
      declare module M:MACa.MAC_Scheme { CPA_Wrap, SKEa.CPA.CPA_Wrap, MACa.SUF_CMA.SUF_Wrap, E }.
      declare module A:CPA_Adversary   { CPA_Wrap, SKEa.CPA.CPA_Wrap, MACa.SUF_CMA.SUF_Wrap, E, M }.

      local lemma CPA_prob &m:
        Pr[IND_CPA(EtM(E,M),A).main() @ &m: res]
        = Pr[SKEa.CPA.IND_CPA(E,CPAa(M,A)).main() @ &m: res].
      proof.
        byequiv=> //=.
        proc; inline *; swap{2} 3 -1.
        wp; call (_:    ={glob E, glob M}
                     /\ CPA_Wrap.b{1} = SKEa.CPA.CPA_Wrap.b{2}
                     /\ CPA_Wrap.k{1} = (SKEa.CPA.CPA_Wrap.k,MACa.SUF_CMA.SUF_Wrap.k){2}).
          proc; inline *; sp; if=> //=.
          rcondt{2} 4; 1:by auto.
          wp; call (_: true).
          wp; call (_: true).
          by auto.
        rnd.
        wp; call (_: true).
        by wp; call (_: true).
      qed.

      (* Adv^{CPA}_{EtM(E,M)}(A) = Adv^{CPA}_{E}(CPAa(A)) *)
      lemma CPA_preservation &m:
        2%r * Pr[IND_CPA(EtM(E,M),A).main() @ &m: res] - 1%r
        = 2%r * Pr[SKEa.CPA.IND_CPA(E,CPAa(M,A)).main() @ &m: res] - 1%r.
      proof. by rewrite (CPA_prob &m). qed.
    end section CPA.

    (* print CPA_prob *)
    print CPA_preservation.
  end CPA_SUF_CPA.

  (** We then prove that if E is IND-CPA and M is SUF-CMA then EtM(E,M) is INT-CTXT **)
  theory CPA_SUF_CTXT.
    import CTXT.

    (* The SKE and the CTXT adversary against EtM(E,M) are combined
       to construct a CMA adversary againt M                           *)
    module CMAa(E:SKEa.Enc_Scheme, A:CTXT_Adversary, O:MACa.CMA_Oracles) = {
      module Sim : CTXT_Oracles = {
        proc enc(p:ptxt): ctxt * tag = {
          var c, t;

          c <@ E.enc(SKEa.CPA.CPA_Wrap.k,p);
          t <@ O.tag(c);
          return (c,t);
        }

        proc verify(ct:ctxt * tag): bool = {
          var c, t, b;

          (c,t) <- ct;
          b     <@ O.verify(c,t);
          return b;
        }
      }

      proc forge(): unit = {
        SKEa.CPA.CPA_Wrap.k <@ E.keygen();
                               A(Sim).forge();
      }
    }.

    section CTXT.
      declare module E:SKEa.Enc_Scheme { CTXT_Wrap, SKEa.CPA.CPA_Wrap, MACa.SUF_CMA.SUF_Wrap }.
      declare module M:MACa.MAC_Scheme { CTXT_Wrap, SKEa.CPA.CPA_Wrap, MACa.SUF_CMA.SUF_Wrap, E }.
      declare module A:CTXT_Adversary  { CTXT_Wrap, SKEa.CPA.CPA_Wrap, MACa.SUF_CMA.SUF_Wrap, E, M }.

      (* Equivalence up to failure requires termination of oracles and adversaries *)
      axiom E_keygen_ll: islossless E.keygen.
      axiom E_enc_ll   : islossless E.enc.
      axiom E_dec_ll   : islossless E.dec.

      axiom M_keygen_ll: islossless M.keygen.
      axiom M_tag_ll   : islossless M.tag.
      axiom M_verify_ll: islossless M.verify.

      axiom A_forge_ll (O <: CTXT_Oracles { A }):
        islossless O.enc => islossless O.verify => islossless A(O).forge.

      (* In addition, this result requires that the encryption scheme is correct,
         and that the decryption algorithm is deterministic and stateless *)
      axiom dec_op: exists dec,
           (forall ge _k _c,
              hoare [E.dec: (glob E) = ge /\ k = _k /\ c = _c
                        ==> (glob E) = ge /\ res = dec _k _c])
        /\ (forall _k _p,
              hoare [E.enc: k = _k /\ p = _p ==> dec _k res = Some _p]).
      choice dec with dec_op.

      hoare dec_sem ge _k _c:
        E.dec: (glob E) = ge /\ k = _k /\ c = _c
           ==> (glob E) = ge /\ res = dec _k _c.
      proof. have [h _]:= decE; exact/(h ge _k _c). qed.

      hoare E_correct _k _p:
        E.enc: k = _k /\ p = _p ==> dec _k res = Some _p.
      proof. have [_ h]:= decE; exact/(h _k _p). qed.

      (* Useful consequences of these facts *)
      local equiv enc_eq _k _p: E.enc ~ E.enc:
            ={glob E, k, p} /\ k{1} = _k /\ p{1} = _p
        ==> ={glob E, res} /\ dec _k res{1} = Some _p.
      proof.
        conseq* (_: ={glob E, k, p} ==> ={glob E, res}) (E_correct _k _p) _.
        by proc true.
      qed.

      local phoare dec_ph ge _k _c:
        [E.dec: (glob E) = ge /\ k = _k /\ c = _c
            ==> (glob E) = ge /\ res = dec _k _c] =1%r.
      proof. by conseq* E_dec_ll (dec_sem ge _k _c). qed.

      (* Adv^{CTXT}_{EtM(E,M)}(A) <= Adv^{SUF-CMA}_{M}(CMAa(E,A)) *)
      lemma CTXT_security &m:
        Pr[INT_CTXT(EtM(E,M),A).main() @ &m: res]
        <= Pr[MACa.SUF_CMA.SUF_CMA(M,CMAa(E,A)).main() @ &m: res].
      proof.
        byequiv=> //=.
        proc; inline *.
        call (_: MACa.SUF_CMA.SUF_Wrap.win,
                    ={glob E, glob M}
                 /\ CTXT_Wrap.k{1} = (SKEa.CPA.CPA_Wrap.k,MACa.SUF_CMA.SUF_Wrap.k){2}
                 /\ (forall p, mem p CTXT_Wrap.s{1} <=> mem p MACa.SUF_CMA.SUF_Wrap.s{2})
                 /\ (forall c t, mem (c,t) CTXT_Wrap.s{1} => dec SKEa.CPA.CPA_Wrap.k{2} c <> None)
                 /\ (CTXT_Wrap.win{1} => MACa.SUF_CMA.SUF_Wrap.win{2})).
          (* adversary is lossless *)
          exact/A_forge_ll.
          (* encryption oracle *)
          (* equivalence *)
          proc; inline *.
          wp; call (_: true).
          wp; sp. exists* ek{1}, p0{1}; elim* => _k _p. (* making use of E_correct *)
          by call (enc_eq _k _p); skip; smt.
          (* lossless after win *)
          by move=> &2 win; proc; wp; call (EtM_enc_ll E M E_enc_ll M_tag_ll).
          (* lossless and preservation of win *)
          move=> &1; proc; inline *.
          wp; call M_tag_ll.
          by wp; call E_enc_ll.
          (* decryption oracle *)
          (* equivalence *)
          proc; inline *.
          seq  6  4: (   !MACa.SUF_CMA.SUF_Wrap.win{2}
                      /\ ={glob E, glob M}
                      /\ b{1} = b0{2}
                      /\ c{1} = ct{2}
                      /\ CTXT_Wrap.k{1} = (SKEa.CPA.CPA_Wrap.k,MACa.SUF_CMA.SUF_Wrap.k){2}
                      /\ (forall p, mem p CTXT_Wrap.s{1} <=> mem p MACa.SUF_CMA.SUF_Wrap.s{2})
                      /\ (forall c t, mem (c,t) CTXT_Wrap.s{1} => dec SKEa.CPA.CPA_Wrap.k{2} c <> None)
                      /\ (CTXT_Wrap.win{1} => MACa.SUF_CMA.SUF_Wrap.win{2})
                      /\ k{1}  = CTXT_Wrap.k{1}
                      /\ ct{1} = c{1}
                      /\ c{2}  = ct{2}.`1
                      /\ t{2}  = ct{2}.`2
                      /\ p0{1} = None
                      /\ m{2}  = c{2}
                      /\ ek{1} = k{1}.`1
                      /\ mk{1} = k{1}.`2
                      /\ t0{2} = t{2}
                      /\ c0{1} = ct{1}.`1
                      /\ t{1}  = ct{1}.`2).
            by wp; call (_: true); auto.
          if{1}.
            wp. exists* (glob E){1}, ek{1}, c0{1}; elim* => ge _k _c.
            by call{1} (dec_ph ge _k _c); skip; smt.
          by auto; smt.
        (* lossless after win *)
        by move=> &2 bad; proc; wp; call (EtM_dec_ll E M E_dec_ll M_verify_ll).
        (* lossless and preservation of win *)
        move=> &1; proc; seq  2: true 1%r 1%r 0%r _ (MACa.SUF_CMA.SUF_Wrap.win) => //=.
          by inline *; wp; call (_: true); auto; smt.
          by inline *; wp; call M_verify_ll; auto.
        (* back to the experiment *)
        swap{2} 4 -3.
        wp; call (_: true).
        by wp; call (_: true); skip; smt.
      qed.
    end section CTXT.
  end CPA_SUF_CTXT.

  (** Finally, we put everything together using the generic result
      from the beginning. **)
  theory CPA_SUF_CCA.
    import CPA CTXT CCA CPA_CTXT_CCA.

    (** Given a CCA adversary against EtM(E,M), we want to construct:
          1) a CPA adversary against E; and
          2) a CMA adversary against M.
        We do so by first constructing:
          3) a CPA adversary against EtM(E,M);
          4) a CTXT adversary against EtM(E,M)
        using the generic result, and using those to construct
        the final adversaries.                                 **)

    (** The adversaries 1) and 2) can simply be expressed as follows **)
    module CPAa(M:MACa.MAC_Scheme,A:CCA_Adversary,O:SKEa.CPA.CPA_Oracles) =
      CPA_SUF_CPA.CPAa(M,CPA_CTXT_CCA.CPAa(A),O).

    module CMAa(E:SKEa.Enc_Scheme,A:CCA_Adversary,O:MACa.CMA_Oracles) =
      CPA_SUF_CTXT.CMAa(E,CPA_CTXT_CCA.CTXTa(A),O).

    (** We now prove the desired result: given an SKE E and a MAC M,
        the folowing holds for any CCA adversary A against EtM(E,M):
          Adv^{CCA}_{EtM(E,M)}(A)
          <= Adv^{CPA}_{E}(CPAa(M,A))
             + 2 * Adv^{SUF-CMA}_{M}(CMAa(E,A)) **)
    section CPA_SUF_CCA.
      declare module E:SKEa.Enc_Scheme { CTXTa, CPA_Wrap, CTXT_Wrap, CCA_Wrap, SKEa.CPA.CPA_Wrap, MACa.SUF_CMA.SUF_Wrap }.
      declare module M:MACa.MAC_Scheme { CTXTa, CPA_Wrap, CTXT_Wrap, CCA_Wrap, SKEa.CPA.CPA_Wrap, MACa.SUF_CMA.SUF_Wrap, E }.
      declare module A:CCA_Adversary   { CTXTa, CPA_Wrap, CTXT_Wrap, CCA_Wrap, SKEa.CPA.CPA_Wrap, MACa.SUF_CMA.SUF_Wrap, E, M }.

      axiom E_keygen_ll: islossless E.keygen.
      axiom E_enc_ll   : islossless E.enc.
      axiom E_dec_ll   : islossless E.dec.

      axiom M_keygen_ll: islossless M.keygen.
      axiom M_tag_ll   : islossless M.tag.
      axiom M_verify_ll: islossless M.verify.

      axiom A_distinguish_ll (O <: CCA_Oracles { A }):
        islossless O.lr => islossless O.dec => islossless A(O).distinguish.

      axiom dec_op: exists dec,
           (forall ge _k _c,
              hoare [E.dec: (glob E) = ge /\ k = _k /\ c = _c
                        ==> (glob E) = ge /\ res = dec _k _c])
        /\ (forall _k _p,
              hoare [E.enc: k = _k /\ p = _p ==> dec _k res = Some _p]).
      choice dec with dec_op.

      axiom verify_nomod gm: hoare [M.verify: (glob M) = gm ==> (glob M) = gm].

      (** Adversary inlining **)
      lemma fold_CPAa &m:
        Pr[SKEa.CPA.IND_CPA(E, CPA_SUF_CPA.CPAa(M, CPA_CTXT_CCA.CPAa(A))).main() @ &m : res]
        = Pr[SKEa.CPA.IND_CPA(E, CPAa(M,A)).main() @ &m: res].
      proof. by byequiv=> //=; sim. qed.

      lemma fold_CMAa &m:
        Pr[MACa.SUF_CMA.SUF_CMA(M, CPA_SUF_CTXT.CMAa(E, CPA_CTXT_CCA.CTXTa(A))).main() @ &m : res]
        = Pr[MACa.SUF_CMA.SUF_CMA(M, CMAa(E,A)).main() @ &m: res].
      proof. by byequiv=> //=; sim. qed.

      (** And concluding **)
      lemma CCA_security &m:
        2%r * Pr[IND_CCA(EtM(E,M),A).main() @ &m: res] - 1%r
        <= 2%r * Pr[SKEa.CPA.IND_CPA(E,CPAa(M,A)).main() @ &m: res] - 1%r
           + 2%r * Pr[MACa.SUF_CMA.SUF_CMA(M,CMAa(E,A)).main() @ &m: res].
      proof.
        (* Pushing some facts into the local context to help [trivial] *)
        move: E_keygen_ll E_enc_ll E_dec_ll M_keygen_ll M_tag_ll M_verify_ll
           => E_keygen_ll E_enc_ll E_dec_ll M_keygen_ll M_tag_ll M_verify_ll.
        have [dec_sem E_correct]:= decE.
        have CTXTa_forge_ll: forall (O <: CTXT_Oracles {CPA_CTXT_CCA.CTXTa(A)} ),
                               islossless O.enc =>
                               islossless O.verify => 
                               islossless CPA_CTXT_CCA.CTXTa(A, O).forge.
          move=> O O_enc_ll O_verify_ll.
          proc; call (_: true).
            exact/A_distinguish_ll.
            by proc; sp; if=> //=; call O_enc_ll; wp.
            by proc; call O_verify_ll.
          by auto; smt.
        have := CPA_SUF_CTXT.CTXT_security E M (CPA_CTXT_CCA.CTXTa(A)) _ _ _ _ _ _ _ _ &m=> //=.
          exact/dec_op.
        have := CPA_SUF_CPA.CPA_preservation E M (CPA_CTXT_CCA.CPAa(A)) &m.
        rewrite (fold_CPAa &m)=> <-.
        have := CPA_CTXT_CCA.CCA_security (EtM(E,M)) A _ _ _ _ _ &m => //=.
          exact/(EtM_keygen_ll E M).
          exact/(EtM_enc_ll E M).
          exact/(EtM_dec_ll E M).
          by move=> O; apply/(A_distinguish_ll O).
          move=> ge; proc; seq  4: (((glob M), (glob E)) = ge).
            by sp; exists* (glob M); elim* => gm; call (verify_nomod gm).
            by if=> //=; exists* (glob E), ek, c; elim* => ge' _k _c; call (dec_sem ge' _k _c).
        smt.
      qed.
    end section CPA_SUF_CCA.
  end CPA_SUF_CCA.
end EtM.

print EtM.CPA_SUF_CCA.CCA_security.
